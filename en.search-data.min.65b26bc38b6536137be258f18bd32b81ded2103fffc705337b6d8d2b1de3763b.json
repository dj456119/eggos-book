[{"id":0,"href":"/docs/quick-start/boot-from-cd/","title":"1.1 从ISO镜像启动","section":"第一章 快速开始","content":"本节将帮助大家下载ISO镜像，并从虚拟机启动eggos。\n下载镜像文件 #  直接使用ISO镜像来启动eggos，可以免去我们编译整个项目的麻烦，特别是我们刚开始的时候想快速体验eggos的功能的时候。\neggos在每个版本会生成一个ISO镜像文件，我们可以从github的release界面直接下载，从网址 https://github.com/icexin/eggos/releases 进入到eggos的release界面，点击eggos.iso下载。\n虚拟机启动ISO文件 #  我们以linux系统为例，windows系统可以用wsl的方式来启动linux子系统，操作类似。\nubuntu的用户可以通过命令 sudo apt install qemu-system-x86 来安装qemu虚拟机。\n使用如下命令来启动虚拟机:\n$ qemu-system-x86_64 -m 256M -no-reboot -serial mon:stdio -netdev user,id=eth0,hostfwd=tcp::8080-:80 -device e1000,netdev=eth0 -cdrom eggos.iso 没有图形界面终端，如windows的wsl需要加上-nographic，从而以非图形化方式启动qemu  顺利启动后的画面如下：\n "},{"id":1,"href":"/docs/boot-loader/grub/","title":"2.1 使用grub","section":"第二章 Boot Loader","content":"TODO\n"},{"id":2,"href":"/docs/quick-start/play-eggos/","title":"1.2 体验eggos","section":"第一章 快速开始","content":"体验eggos #  上一节我们通过ISO镜像启动了eggos系统。\n启动eggos成功后，我们就可以体验一些内置功能了。默认情况下有个类似linux的终端界面，在这个终端界面下我们可以输入命令来操作eggos。\n这一节我们来体验下eggos的一些功能。\nJavascript解释器 #  输入如下命令来启动交互式Javascript解释器\n$ js 之后我们就可以输入合法的Javascript语句来执行。\n\u0026gt;\u0026gt;\u0026gt; console.log(\u0026#34;hello world\u0026#34;) hello world \u0026gt;\u0026gt;\u0026gt; reg = new RegExp(\u0026#34;hello\u0026#34;) \u0026gt;\u0026gt;\u0026gt; console.log(reg) /hello/ \u0026gt;\u0026gt;\u0026gt; resp = reg.test(\u0026#34;hello world\u0026#34;) \u0026gt;\u0026gt;\u0026gt; console.log(resp) true 这个Javascript解释器内置了一个简单的http.Get方法，用于从一个url里面获取内容。\n\u0026gt;\u0026gt;\u0026gt; var url = \u0026#34;http://baidu.com\u0026#34; \u0026gt;\u0026gt;\u0026gt; resp = http.Get(url) \u0026gt;\u0026gt;\u0026gt; console.log(resp) \u0026lt;html\u0026gt; \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;0;url=http://www.baidu.com/\u0026#34;\u0026gt; \u0026lt;/html\u0026gt; 它甚至有自动补全功能，输入http.之后敲击\u0026lt;TAB\u0026gt;键，就可以补全出http.Get。重复按\u0026lt;TAB\u0026gt;可以在多个候选结果间切换。\n按\u0026lt;Crtl+D\u0026gt;来退出Javascript解释器。\n文件系统 #  eggos现在没有实现完整的文件系统，而是使用了 afero作为文件系统的抽象接口。\n我们通过mount命令挂载一个samba文件系统来体验eggos的文件系统功能。\nroot@eggos# mount smb://icexin:eggos@172.28.90.3:445/sambashare /share root@eggos# cd /share root@eggos# ls -rw-rw-rw- 111 fib.js root@eggos# cat fib.js function fib(n) { if (n == 1 || n == 2) { return 1; } return fib(n-1) + fib(n-2); } console.log(fib(10)) root@eggos# js fib.js 55 解释一下上面我们做了什么：\n首先我们通过mount命令将一个samba地址挂载到了本地的一个目录\n mount的第一个参数是源地址URI，第二个参数是本地的挂载点，这里是/share 源地址URI符合标准的URI格式，其中smb代表我们使用的是samba协议 icexin和eggos分别是samba的账号和密码，读者需要替换成自己的账号和密码 172.28.90.3:445为samba服务器的ip和端口，读者需要替换成自己的ip和端口  接着我们使用cd和ls命令切换到/share目录，并列出目录下的文件，目录下有一个fib.js。\n然后我们使用cat命令打印出fib.js文件的内容，里面使用Javascript实现了斐波那契数列算法，并打印出第10个斐波那契数。\n最后我们执行js命令，用fib.js作为参数，效果是执行了fib.js里面的Javascript代码，打印出结果55。\nHTTP服务 #  eggos内置了一个简单的http服务器，使用go httpd命令即可后台启动HTTP服务器。 这个服务器默认绑定了两个地址：\n /debug/pprof，go著名的pprof地址，里面可以查看很多当前go进程的debug信息 /fs/，根目录的映射，可以从浏览器访问整个文件系统。  打开浏览器，输入http://127.0.0.1:8080/debug/pprof/，即可打开debug页面，从里面我们可以获取当前运行的goroutine堆栈快照。\n 输入http://127.0.0.1:8080/fs/即可访问文件系统根目录，从里面我们可以发现刚刚挂载的/share目录。\n 一路点进去之后我们就能访问/share/fib.js的内容。\n很遗憾的是目前httpd一旦启动就没办法停止，只能重新启动eggos来停止服务  NES模拟器 #  本小节必须在图形界面下运行qemu  eggos内置了一个nes模拟器，也就是我们小时候玩的小霸王游戏机模拟器，可以运行一些简单的任天堂FC游戏。\n接着文件系统那一节的内容，我们这次需要在共享文件夹里面准备一个nes rom。\nroot@eggos# mount smb://icexin:eggos@172.28.90.3:445/sambashare /share root@eggos# ls /share -rw-rw-rw- 111 fib.js -rw-rw-rw- 40976 mario.nes 相比于之前，多了一个mario.nes文件，这个就是我们即将运行的超级马里奥兄弟游戏。\n执行如下命令即可启动nes模拟器，其中-rom参数指定待运行的rom文件。\nroot@eggos# nes -rom /share/mario.nes 如果一切成功的话，可以看到如下画面\n 操作按键是固定的，分别如下:\n W, S, A, D控制手柄的上下左右 K, J控制手柄的A和B 空格和回车控制手柄的选择和开始 Q键可以退出游戏  如果不开启模拟器加速的话，运行会比较卡，MacOS用户可以通过在启动qemu的时候添加-M accel=hvf开启硬件加速，linux用户可以添加-M accel=kvm来启动加速。  小结 #  通过Javascript解释器，文件系统，HTTP服务，NES模拟器这几个应用我们对eggos有了初步的认识，下面章节我们开始搭建eggos开发环境，编写自己的eggos应用。\n扩展阅读 #   [1] A JavaScript interpreter in Go https://github.com/robertkrimen/otto [2] Ubuntu上安装samba服务 https://ubuntu.com/tutorials/install-and-configure-samba [3] NES emulator written in Go https://github.com/fogleman/nes  "},{"id":3,"href":"/docs/quick-start/prepare-env/","title":"1.3 搭建开发环境","section":"第一章 快速开始","content":"我们在上一节快速体验了eggos的基本功能，这一节我们搭建一下eggos的开发环境，为后面的深入分析eggos打下基础。\n核心工具准备 #  基本工具如下：\n go1.13.x mage构建工具 gcc和gdb，需要能生成elf32格式的。 qemu虚拟机  各平台的安装步骤如下所述。\nLinux(ubuntu) #  Go语言编译器 #  $ curl -LO https://golang.google.cn/dl/go1.13.15.linux-amd64.tar.gz $ mkdir $HOME/local \u0026amp;\u0026amp; tar xf -C $HOME/local go1.13.15.linux-amd64.tar.gz # 将$HOME/local/go/bin加入PATH环境变量，这里以bash为例 $ echo \u0026#39;export PATH=$HOME/local/go/bin:$PATH\u0026#39; \u0026gt;\u0026gt; $HOME/.bashrc # 将$HOME/go/bin也加入环境变量，方便执行编译出来的go工具 $ echo \u0026#39;export PATH=$HOME/go/bin:$PATH\u0026#39; \u0026gt;\u0026gt; $HOME/.bashrc $ source $HOME/.bashrc # 设置GOPROXY环境变量，加速package下载 $ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn 按照上面命令执行完毕之后，输入go version命令，如果能正常输入go版本号就证明安装成功了。\nmage构建工具 #  mage是一个类似make的构建工具，但它的makefile是用go语言编写的，可以跨平台，eggos最初是用的makefile，后面切换到mage上了。安装mage也非常简单。\n$ go get github.com/magefile/mage C语言开发套件 #  $ sudo apt-get install build-essential gdb Qemu虚拟机 #  $ sudo apt-get install qemu-system-x86 MacOS #  Go语言编译器 #  $ curl -LO https://golang.google.cn/dl/go1.13.15.darwin-amd64.tar.gz $ mkdir $HOME/local \u0026amp;\u0026amp; tar xf -C $HOME/local go1.13.15.darwin-amd64.tar.gz # 将$HOME/local/go/bin加入PATH环境变量，这里以zsh为例 $ echo \u0026#39;export PATH=$HOME/local/go/bin:$PATH\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc # 将$HOME/go/bin也加入环境变量，方便执行编译出来的go工具 $ echo \u0026#39;export PATH=$HOME/go/bin:$PATH\u0026#39; \u0026gt;\u0026gt; $HOME/.zshrc $ source $HOME/.zshrc # 设置GOPROXY环境变量，加速package下载 $ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn 按照上面命令执行完毕之后，输入go version命令，如果能正常输入go版本号就证明安装成功了。\nmage构建工具 #  $ go get github.com/magefile/mage C语言开发套件 #  $ brew install x86_64-elf-binutils x86_64-elf-gcc x86_64-elf-gdb Qemu虚拟机 #  $ brew install qemu IDE开发环境 #  我们使用vscode来开发eggos。项目默认附带了vscode的配置文件，直接使用vscode打开eggos项目即可开始修改代码。\n安装的插件 #    Go语言插件，用于代码补全，跳转与高亮  GDB插件，用于对内核进行debug，如断点调试  Debug配置 #  需要根据实际情况稍微修改一下.vscode/launch.json里面的配置\n{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;attach\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Attach to qemu\u0026#34;, \u0026#34;executable\u0026#34;: \u0026#34;./kernel.elf\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;:1234\u0026#34;, \u0026#34;remote\u0026#34;: true, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34;, \u0026#34;valuesFormatting\u0026#34;: \u0026#34;parseText\u0026#34;, // 这里根据情况进行替换，linux就用gdb \u0026#34;gdbpath\u0026#34;: \u0026#34;gdb\u0026#34;, // MacOS用下面配置 // \u0026#34;gdbpath\u0026#34;:\u0026#34;x86_64-elf-gdb\u0026#34;, }, ] } 编译运行eggos项目 #  下载代码 #  $ git clone https://github.com/icexin/eggos.git 编译项目 #  $ mage -v multiboot 如果没有报任何错误的话，表示编译很顺利，目录下应该有一个mutiboot.elf文件，这个即是我们的内核文件。\n运行eggos #  # 如果有GUI的话，可以加上这个环境变量，让qemu运行于独立窗口 $ export QEMU_GRAPHIC=true $ mage qemu 如果在终端下运行qemu，可以通过\u0026lt;Ctrl+A C\u0026gt;唤出qemu的console，再输入quit退出qemu模拟  一切顺利的话，就能看到eggos的启动界面了，至此我们完成了eggos的编译和运行。\n小结 #  这一节我们完成了开发环境的搭建，同时完成了eggos项目的编译，并使用qemu虚拟机启动了编译出来的内核。这一节的工作为后面我们编写eggos程序打下了基础。\n下面我们编写第一个eggos程序。\n"},{"id":4,"href":"/docs/quick-start/hello-eggos/","title":"1.4 hello eggos","section":"第一章 快速开始","content":"这一节我们编写第一个eggos的应用程序。\neggos是一个 unikernel，但不妨碍在里面加上功能子模块。\n打开编辑器，在app/cmd目录下新建hello.go，写入如下代码：\npackage cmd import ( \u0026#34;fmt\u0026#34; \u0026#34;github.com/icexin/eggos/app\u0026#34; ) func helloMain(ctx *app.Context) error { fmt.Fprintln(ctx.Stdout, \u0026#34;hello eggos\u0026#34;) return nil } "}]